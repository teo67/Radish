	# Radish implementation of the binary tree data structure #
	

	dig Node plant class {
	    dig val
	    dig left
	    dig right
	    dig constructor plant tool(_val) {
	        this.val plant _val
	        this.left plant null
	        this.right plant null
	    }
	}
	

    dig BinaryTree plant class {
	    dig private head
	    dig constructor plant tool() {
	        this.head plant null
	    }
	    dig add plant tool(val) {
	        if(this.head == null) {
	            this.head plant new Node(val)
	            harvest val
	        }
	        dig current plant this.head
	        while(yes) {
	            if(val < current.val) {
	                if(current.left == null) {
	                    current.left plant new Node(val)
	                    harvest val
	                }
	                current plant current.left
	            } else {
	                if(current.right == null) {
	                    current.right plant new Node(val)
	                    harvest val
	                }
	                current plant current.right
	            }
	        }
	    }
	    dig has plant tool(val) {
	        dig current plant this.head
	        while(current != null) {
	            if(current.val == val) {
	                harvest yes
	            }
	            if(val < current.val) {
	                current plant current.left
	            } else {
	                current plant current.right
	            }
	        }
	        harvest no
	    }
	    dig invert plant tool(branch p this.head) {
	        if(branch == null) {
	            end
	        }
	        dig saved plant branch.left
	        branch.left plant branch.right
	        branch.right plant saved
	        this.invert(branch.left)
	        this.invert(branch.right)
	    }
	}
	

	dig binaryTree plant new BinaryTree()
	binaryTree.add(3)
	binaryTree.add(1)
	binaryTree.add(4)
	binaryTree.add(2)
	binaryTree.add(0)
	binaryTree.add(5)
	holler(binaryTree.has(3))
	holler(binaryTree.has(2))
	holler(binaryTree.has(5))
	holler(binaryTree.has(6))
	binaryTree.invert()
	holler(binaryTree.has(2)) # now that the tree is inverted, its method for searching will be backwards relative to the order of the tree #
	# so this will return no #
	

	# output: yes
	yes
	yes
	no
	no #
    holler(binaryTree)